<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>How does nom v.5 work? | abby::blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="What is nom?nom is a parser combinators library written in Rust. Its goal is to provide tools to build safe parsers without compromising the speed or memory consumption. To that end, it uses extensive">
<meta name="keywords" content="nom,Rust,parser,json,nom5">
<meta property="og:type" content="article">
<meta property="og:title" content="How does nom v.5 work?">
<meta property="og:url" content="https://blog.abby.md/2019/05/17/How-does-nom-work/index.html">
<meta property="og:site_name" content="abby::blog">
<meta property="og:description" content="What is nom?nom is a parser combinators library written in Rust. Its goal is to provide tools to build safe parsers without compromising the speed or memory consumption. To that end, it uses extensive">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-05-17T08:11:52.150Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="How does nom v.5 work?">
<meta name="twitter:description" content="What is nom?nom is a parser combinators library written in Rust. Its goal is to provide tools to build safe parsers without compromising the speed or memory consumption. To that end, it uses extensive">
  
    <link rel="alternate" href="/atom.xml" title="abby::blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">abby::blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Simply Technical Sharing</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.abby.md"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-How-does-nom-work" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/17/How-does-nom-work/" class="article-date">
  <time datetime="2019-05-17T00:24:58.000Z" itemprop="datePublished">2019-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      How does nom v.5 work?
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="What-is-nom"><a href="#What-is-nom" class="headerlink" title="What is nom?"></a>What is nom?</h2><p><code>nom</code> is a parser combinators library written in Rust. Its goal is to provide tools to build safe parsers without compromising the speed or memory consumption. To that end, it uses extensively Rust’s strong typing and memory safety to produce fast and correct parsers, and provides functions, macros and traits to abstract most of the error prone plumbing.</p>
<h2 id="Why-this-passage"><a href="#Why-this-passage" class="headerlink" title="Why this passage?"></a>Why this passage?</h2><p><code>nom</code> version 5 is going through a very large change to the lexical syntax to be used. The old way will not work any more. So this passage will tell and explain the new way.</p>
<h2 id="Hello-Color"><a href="#Hello-Color" class="headerlink" title="Hello Color"></a>Hello Color</h2><p>This is a hello world example for parser that we are going to parse Hex color like <code>#2F14DF</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> nom;</span><br><span class="line"><span class="keyword">use</span> nom::&#123;</span><br><span class="line">  IResult,</span><br><span class="line">  bytes::complete::&#123;tag, take_while_m_n&#125;,</span><br><span class="line">  combinator::map_res,</span><br><span class="line">  sequence::tuple</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug,PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> red:   <span class="built_in">u8</span>,</span><br><span class="line">  <span class="keyword">pub</span> green: <span class="built_in">u8</span>,</span><br><span class="line">  <span class="keyword">pub</span> blue:  <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">from_hex</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">u8</span>, std::num::ParseIntError&gt; &#123;</span><br><span class="line">  <span class="built_in">u8</span>::from_str_radix(input, <span class="number">16</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_hex_digit</span></span>(c: <span class="built_in">char</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">  c.is_digit(<span class="number">16</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hex_primary</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; IResult&lt;&amp;<span class="built_in">str</span>, <span class="built_in">u8</span>&gt; &#123;</span><br><span class="line">  map_res(</span><br><span class="line">    take_while_m_n(<span class="number">2</span>, <span class="number">2</span>, is_hex_digit),</span><br><span class="line">    from_hex</span><br><span class="line">  )(input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hex_color</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; IResult&lt;&amp;<span class="built_in">str</span>, Color&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (input, _) = tag(<span class="string">"#"</span>)(input)?;</span><br><span class="line">  <span class="keyword">let</span> (input, (red, green, blue)) = tuple((hex_primary, hex_primary, hex_primary))(input)?;</span><br><span class="line"></span><br><span class="line">  <span class="literal">Ok</span>((input, Color &#123; red, green, blue &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_color</span></span>() &#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(hex_color(<span class="string">"#2F14DF"</span>), <span class="literal">Ok</span>((<span class="string">""</span>, Color &#123;</span><br><span class="line">    red: <span class="number">47</span>,</span><br><span class="line">    green: <span class="number">20</span>,</span><br><span class="line">    blue: <span class="number">223</span>,</span><br><span class="line">  &#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The combinator is writting in a very functional way.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (input, _) = tag(<span class="string">"#"</span>)(input)?;</span><br><span class="line"><span class="keyword">let</span> (input, (red, green, blue)) = tuple((hex_primary, hex_primary, hex_primary))(input)?;</span><br><span class="line"></span><br><span class="line"><span class="literal">Ok</span>((input, Color &#123; red, green, blue &#125;))</span><br></pre></td></tr></table></figure>
<p>That, <code>tag(&quot;#&quot;)</code>, <code>tuple((hex_primary, hex_primary, hex_primary))</code> are functions.</p>
<h2 id="Parse-Json"><a href="#Parse-Json" class="headerlink" title="Parse Json"></a>Parse Json</h2><p>Then we come to the real world. They provided a very efficient Json parser as an example of nom.</p>
<p>Please find the example <a href="https://github.com/Geal/nom/blob/master/examples/json.rs" target="_blank" rel="noopener">here</a>.</p>
<p>Revision, this is the defination or state-machine of Json.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">JsonValue</span></span> &#123;</span><br><span class="line">  Str(<span class="built_in">String</span>),</span><br><span class="line">  Boolean(<span class="built_in">bool</span>),</span><br><span class="line">  Num(<span class="built_in">f64</span>),</span><br><span class="line">  Array(<span class="built_in">Vec</span>&lt;JsonValue&gt;),</span><br><span class="line">  Object(HashMap&lt;<span class="built_in">String</span>, JsonValue&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The following are lexical elements:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sp</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> chars = <span class="string">" \t\r\n"</span>;</span><br><span class="line"></span><br><span class="line">  take_while(<span class="keyword">move</span> |c| chars.contains(c))(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Space should be obvious.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">float</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, <span class="built_in">f64</span>, E&gt; &#123;</span><br><span class="line">  flat_map!(i, recognize_float, parse_to!(<span class="built_in">f64</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nom provided features <code>recognize_float</code> and <code>parse_to</code> to do it automatically.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_str</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, E&gt; &#123;</span><br><span class="line">    escaped!(i, call!(alphanumeric), <span class="string">'\\'</span>, one_of!(<span class="string">"\"n\\"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>call!()</code> is a macro to call a named function as callback. It can also take in argument like below.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_wrapper</span></span>(input: &amp;[<span class="built_in">u8</span>], i: <span class="built_in">u8</span>) -&gt; IResult&lt;&amp;[<span class="built_in">u8</span>], &amp;[<span class="built_in">u8</span>]&gt; &#123; take!(input, i * <span class="number">10</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// will make a parser taking 20 bytes</span></span><br><span class="line">named!(parser, call!(take_wrapper, <span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>For <code>one_of!()</code>:<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">named!(simple&lt;<span class="built_in">char</span>&gt;, one_of!(&amp;<span class="string">b"abc"</span>[..]));</span><br><span class="line"><span class="built_in">assert_eq!</span>(simple(<span class="string">b"a123"</span>), <span class="literal">Ok</span>((&amp;<span class="string">b"123"</span>[..], <span class="string">'a'</span>)));</span><br><span class="line"></span><br><span class="line">named!(a_or_b&lt;&amp;<span class="built_in">str</span>, <span class="built_in">char</span>&gt;, one_of!(<span class="string">"ab汉"</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(a_or_b(<span class="string">"汉jiosfe"</span>), <span class="literal">Ok</span>((<span class="string">"jiosfe"</span>, <span class="string">'汉'</span>)));</span><br></pre></td></tr></table></figure></p>
<p>This following code will extract string lexical elements by <code>{&quot;...&quot;}</code>. We can see that delimiters actually helps programmer to write parsers.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">string</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (i, _) = <span class="built_in">char</span>(<span class="string">'\"'</span>)(i)?;</span><br><span class="line">  context(<span class="string">"string"</span>, terminated(parse_str, <span class="built_in">char</span>(<span class="string">'\"'</span>)))(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Boolean is a simple tag.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">boolean</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(input: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, <span class="built_in">bool</span>, E&gt; &#123;</span><br><span class="line">  alt( (</span><br><span class="line">      |i| tag(<span class="string">"false"</span>)(i).map(|(i,_)| (i, <span class="literal">false</span>)),</span><br><span class="line">      |i| tag(<span class="string">"true"</span>)(i).map(|(i,_)| (i, <span class="literal">true</span>))</span><br><span class="line">  ))(input)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">array</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, <span class="built_in">Vec</span>&lt;JsonValue&gt;, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (i, _) = <span class="built_in">char</span>(<span class="string">'['</span>)(i)?;</span><br><span class="line"></span><br><span class="line">  context(</span><br><span class="line">    <span class="string">"array"</span>,</span><br><span class="line">    terminated(</span><br><span class="line">      |i| separated_listc(i, preceded(sp, <span class="built_in">char</span>(<span class="string">','</span>)), value),</span><br><span class="line">      preceded(sp, <span class="built_in">char</span>(<span class="string">']'</span>)))</span><br><span class="line">     )(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">key_value</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, (&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, JsonValue), E&gt; &#123;</span><br><span class="line">  separated_pair!(i, preceded!(sp, string), preceded!(sp, char!(<span class="string">':'</span>)), value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>preceded</code> is a tool to check if defined something is following.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">named!(parser&lt;&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>&gt;, preceded!(char!(<span class="string">'-'</span>), alpha1));</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"-abc"</span>), <span class="literal">Ok</span>((<span class="string">""</span>, <span class="string">"abc"</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"abc"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">"abc"</span>, ErrorKind::Char))));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"-123"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">"123"</span>, ErrorKind::Alpha))));</span><br></pre></td></tr></table></figure>
<p><code>separated_list</code> is a string <code>split</code> in native Rust (or other languages).</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hash</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, HashMap&lt;<span class="built_in">String</span>, JsonValue&gt;, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (i, _) = <span class="built_in">char</span>(<span class="string">'&#123;'</span>)(i)?;</span><br><span class="line">  context(</span><br><span class="line">    <span class="string">"map"</span>,</span><br><span class="line">    terminated(</span><br><span class="line">      |i| map!(i,</span><br><span class="line">        separated_list!(preceded!(sp, char!(<span class="string">','</span>)), key_value),</span><br><span class="line">        |tuple_vec| tuple_vec</span><br><span class="line">          .into_iter()</span><br><span class="line">          .map(|(k, v)| (<span class="built_in">String</span>::from(k), v))</span><br><span class="line">          .collect()</span><br><span class="line">      ),</span><br><span class="line">      preceded(sp, <span class="built_in">char</span>(<span class="string">'&#125;'</span>)))</span><br><span class="line">     )(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>terminated()!</code> returns the result of its first parser if both succeed</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">named!(parser&lt;&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>&gt;, terminated!(alpha1, char!(<span class="string">';'</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"abc;"</span>), <span class="literal">Ok</span>((<span class="string">""</span>, <span class="string">"abc"</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"abc,"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">","</span>, ErrorKind::Char))));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"123;"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">"123;"</span>, ErrorKind::Alpha))));</span><br></pre></td></tr></table></figure>
<p>and it also takes the third parameter which is a callback like the second parameter in nom 4.3.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map!(i,</span><br><span class="line">    separated_list!(preceded!(sp, char!(<span class="string">','</span>)), key_value),</span><br><span class="line">    |tuple_vec| tuple_vec</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|(k, v)| (<span class="built_in">String</span>::from(k), v))</span><br><span class="line">        .collect()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>At the end:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, JsonValue, E&gt; &#123;</span><br><span class="line">  preceded!(i,</span><br><span class="line">    sp,</span><br><span class="line">    alt!(</span><br><span class="line">      hash    =&gt; &#123; |h| JsonValue::Object(h)            &#125; |</span><br><span class="line">      array   =&gt; &#123; |v| JsonValue::Array(v)             &#125; |</span><br><span class="line">      string  =&gt; &#123; |s| JsonValue::Str(<span class="built_in">String</span>::from(s)) &#125; |</span><br><span class="line">      float   =&gt; &#123; |f| JsonValue::Num(f)               &#125; |</span><br><span class="line">      boolean =&gt; &#123; |b| JsonValue::Boolean(b)           &#125;</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alt</code> try a list of parsers and return the result of the first successful one.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.abby.md/2019/05/17/How-does-nom-work/" data-id="cjvrt1daa0000bcos668d9p7u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nom-Rust-parser-json-nom5/">nom,Rust,parser,json,nom5</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/05/16/multicasting-in-rust/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Multicasting in Rust</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust-ipv4-ipv6-multicast-udp/">Rust,ipv4,ipv6,multicast,udp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nom-Rust-parser-json-nom5/">nom,Rust,parser,json,nom5</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Rust-ipv4-ipv6-multicast-udp/" style="font-size: 10px;">Rust,ipv4,ipv6,multicast,udp</a> <a href="/tags/nom-Rust-parser-json-nom5/" style="font-size: 10px;">nom,Rust,parser,json,nom5</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/17/How-does-nom-work/">How does nom v.5 work?</a>
          </li>
        
          <li>
            <a href="/2019/05/16/multicasting-in-rust/">Multicasting in Rust</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Abby Chau<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>