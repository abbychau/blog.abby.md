---
title: draft
date: 2021-02-26 16:10:13
categories: 遊藝
---

上班摸個魚, 說說關於反射的那些事。

對於Java 和.NET 的廣大民工（不包括我）來說，學習框架似乎就是在市場提供生產力的本命。
而現代框架中，都不能避免出現Attribute/Annotation 式的標注。

這種標注都會在「框架」層面以反射形式分析，以在實際以在確定的運行次序上觸法各個時間點上和條件上的勾子。

這種在VM/解釋器層面上解構語法然後組成IR 的方法，有沒有很像。。。Eval 和Goto?
我們大多不喜歡Eval ，因為它會出現性能問題，也令閱讀程式碼時加入一層腦內的堆積(heap)。

人類在閱讀時加入heap 是一項「有挑戰性」的工作。
A=2222；B=1111；C=A+B；Print("I have $"+C);
像這種簡單的狀態對大部分人來說是輕鬆的。因為在閱讀時，讀者都有一種在猜測寫作目的的自動回收器。
以上面這個例子來說，讀到Print 時就會把「A=2222；B=1111；C=A+B；」回收了。留下「I have $3333」這樣的句子。

雖然作用不盡相似，但Eval和Goto 都是令回收（很抱歉要用和GC 同一個動詞）不能執行的工具。
 Attribute 也是，和eval 相似，我們要記下所有作者寫下的勾子定義。

Eval 是這種:
我收到一封信，可以被小貓撕碎了。
第1片寫著 A=
第2片寫著 1111
第3片寫著 C=A+B；Print("I have $"+C);
第4片寫著 2222; B=
按1,4,2,3 的次序排好再閱讀:

Attribute 是:
當我回到家時, 在袋裡找找有沒有home 的信封，
當我睡覺前，在袋裡找找有沒有sleep 的信封,
....
有的話就按指示做