<html>

<head>
    <title>PHP 的協程化是什麽意思？</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base target="_blank">
    <link rel="stylesheet" href="https://blog.abby.md/style.css" />
    <link rel="icon" type="image/png"
        href="https://blog.abby.md/favicon.png" />
    

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/default.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/highlight.min.js"></script>

</head>

<body>
    
    <div id='article' style='padding:0 15px 10px 10px'>
        <h1 id="subject">PHP 的協程化是什麽意思？</h1>
        <div id="date" style='font-size: 9pt;'>2019-09-25 05:41</div>
        <div style='font-size: 9pt; border-bottom:1px solid #444; padding-bottom:1em' id="tags">答案</div>
        <div id="content" style='word-break: break-all;'><p>1. 因為協程是共用同一進程的，如果不修改，則會引起堵塞。<br><br>2. 理論上來說，協程的並發是軟時間分片，而如何分片則是Reactor 和它的上層實現來解決的。<br><br>方法上都是把客戶端重寫一次。<br>以已經能使用協程的curl / mysql / redis 三個協定為例。<br><br>因為Swoole 早完成了swoole_http_client_coro 的http 客戶端，所以把Curl 的接口重定向一次就完了。<br>也就是說, 你在寫go() 時看見的curl_* ，其實是在利用swoole_http_client_coro。<br><br>而swoole_mysql_coro 則是基於mysqlnd, 以 `swoole::coroutine::Socket;` 發起連接。<br><a href="http://link.zhihu.com/?target=https%3A//github.com/swoole/swoole-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_mysql_coro.cc%23L760%3A20" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/swoole/swool</span><span class="invisible">e-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_mysql_coro.cc#L760:20</span><span class="ellipsis"></span></a><br><br>而redis 則是利用 hiredis + `swoole::coroutine::Socket;` , socket 是交回全局的SwooleTG.reactor 管理的。<br><a href="http://link.zhihu.com/?target=https%3A//github.com/swoole/swoole-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_redis_coro.cc%23L1248%3A13" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/swoole/swool</span><span class="invisible">e-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_redis_coro.cc#L1248:13</span><span class="ellipsis"></span></a></p><p>而co::exec() 則是利用 sh 對命令產生一個新的fd 再用`swoole::coroutine::Socket;`循環讀取<br><a href="http://link.zhihu.com/?target=https%3A//github.com/swoole/swoole-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_coroutine_system.cc%23L798" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/swoole/swool</span><span class="invisible">e-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_coroutine_system.cc#L798</span><span class="ellipsis"></span></a><br>可見在Swoole 中的Socket 十分重要。</p><p><br>3. 如果在類中有出現過掛起線程的動作，那就一定要修改了。如果有堵塞，則會令並發失效。</p></div>
        <div id="permalink" style='word-break: break-all;padding:2em 0 2em 0'><a href="https://blog.abby.md/_generated_pages/answers/835134974.htm">Permalink of this blog</a></div>
        
    </div>
</body>
<script>
    $("img[data-actualsrc]").each(function(num,e){
        $(this).attr("src",$(this).attr("data-actualsrc"));
    });
    hljs.highlightAll();
</script>
</html>