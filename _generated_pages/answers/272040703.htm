<html>

<head>
    <title>如何從性能方面選擇for，map和forEach？</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://blog.abby.md/style.css" />
    <link rel="icon" type="image/png"
        href="https://blog.abby.md/favicon.png" />
    

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/default.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/highlight.min.js"></script>
    <script src="/script.js"></script>
</head>

<body>
    
    <div id='article' style='padding:0 15px 10px 10px'>
        <h1 id="subject">如何從性能方面選擇for，map和forEach？</h1>
        <div id="date" style='font-size: 9pt;'>2017-12-06 15:51</div>
        <div style='font-size: 9pt; border-bottom:1px solid #444; padding-bottom:1em' id="tags">答案</div>
        <div id="content" style='word-break: break-all;'><p>很直觀地說</p><p>for 和array 本身沒有關係, 速度最快</p><p>forEach 有這兩個overheads: "要求檢查下一項是否為空, 並複制到callback 中"</p><p>map 則在forEach的基礎上, 要求function 抽象化的開銷和整串複制的記憶體</p><p><br></p><p>map 明顯不在同一個數量級的。但要比較for 和forEach, 則沒有那麼簡單。</p><p><br></p><p>眾所周知js 是弱型態但V8 卻是機器碼, 我們可以聯想到每個不同的forEach 之中, 在V8 的優化都是不一樣的。</p><p>因此, 有不少人都發現了很多奇妙的狀況。</p><p><br></p><p>付上連結:</p><p><a href="http://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/42467948/in-javascript-v8-why-does-foreach-on-an-array-consume-much-more-memory-than-a" class=" wrap external" target="_blank" rel="nofollow noreferrer">In Javascript (V8) why does forEach on an array consume much more memory than a simple for loop?</a></p><p>這哥用Node 7.5 跑了下面這兩段</p><div class="highlight"><pre><code class="language-js"><span></span><span class="kd">let</span> <span class="nx">regressData</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">x</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">regressData</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">y</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">regressData</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">random</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">validateFor</span><span class="p">(</span><span class="nx">regressData</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">yxai</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">yxal</span> <span class="o">=</span> <span class="nx">regressData</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">yxai</span> <span class="o">&lt;</span> <span class="nx">yxal</span><span class="p">;</span> <span class="nx">yxai</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">yx</span> <span class="o">=</span> <span class="nx">regressData</span><span class="p">[</span><span class="nx">yxai</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">yxi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">yxl</span> <span class="o">=</span> <span class="nx">yx</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">yxi</span> <span class="o">&lt;</span> <span class="nx">yxl</span><span class="p">;</span> <span class="nx">yxi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">_</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="nx">yx</span><span class="p">[</span><span class="nx">yxi</span><span class="p">]))</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="sb">`non-finite entry at [</span><span class="si">${</span><span class="nx">yxai</span><span class="si">}</span><span class="sb">, </span><span class="si">${</span><span class="nx">yxi</span><span class="si">}</span><span class="sb">]`</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">validateForEach</span><span class="p">(</span><span class="nx">regressData</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">regressData</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">yxa</span><span class="p">,</span> <span class="nx">yxaIndex</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">yxa</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">yx</span><span class="p">,</span> <span class="nx">yxIndex</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">_</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">(</span><span class="nx">yx</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="sb">`non-finite entry at [</span><span class="si">${</span><span class="nx">yxaIndex</span><span class="si">}</span><span class="sb">, </span><span class="si">${</span><span class="nx">yxIndex</span><span class="si">}</span><span class="sb">]`</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">};</span>
</code></pre></div><blockquote>toms-mbp-2:mem_test tommedema$ node --expose-gc test_foreach.js<br>memory consumption before for loop 1549.31 megabyte<br>memory consumption by for loop 0.31 megabyte<br>memory consumption before foreach loop 1549.66 megabyte<br>memory consumption by foreach loop 3087.9 megabyte</blockquote><p>他竟發現了forEach 比for 多用了 3MB</p><p>對伺服器來說, 這可是個大發現!</p><p><br></p><p>下面有一個短答案: 簡單來說, 如果你在這個版本的V8用forEach 的話, 那麼數組有機會變得沒有效率。</p><p><br></p><p>這要回歸到V8 的工作原理說起:</p><p>V8 其實有兩個編譯器 1. full-codegen 2. Crankshaft</p><p>full-codegen 是直接從AST (抽象語法樹) 中抽乾所有的節點來從V8 內置的Macro Assembler 之中直接組譯，這令V8自身的開銷變得很小，很適合在使用頻度不高的程式碼。</p><p>Crankshaft 則是包含了一個高階中介碼(High-level IR)和低階中介碼(Low-level IR)的相連編譯器。Crankshaft 因為在HIR 和LIR 的執行途中會有優化機制，因此執行效率和記憶體使用上都比起full-codegen有極大的優勢。</p><p>透過Type feedback 的機制，當V8判定其中一段程式碼有足夠的熱度(先暫且這樣稱呼)時, 就會利用TypeFeedbackOracle 和AST 中間的連結去把它升級到Crankshaft 中。</p><p>中間的原理十分複雜, 有興趣的可以參考這一篇博客 (<a href="http://link.zhihu.com/?target=https%3A//wingolog.org/archives/2011/07/05/v8-a-tale-of-two-compilers" class=" wrap external" target="_blank" rel="nofollow noreferrer">v8: a tale of two compilers</a>)</p><p><br></p><p>那麼, 在確定測試邏輯無誤後, 要理解效能測試中的數值, 就不得不理解測試熱點有沒有升級到Crankshaft。很不幸地，在這位大哥的版本中，forEach 的運作竟影響了內組數組的儲存機制，然後影響到熱點判定。當然在今天已經修復了。</p><p><br></p><p>而對運作本身, 即使ES 的規格書(<a href="http://link.zhihu.com/?target=https%3A//www.ecma-international.org/ecma-262/5.1/%23sec-15.4.4.18" class=" wrap external" target="_blank" rel="nofollow noreferrer">ECMAScript Language Specification - ECMA-262 Edition 5.1</a>)上要求forEach 執行下面步驟:</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-f4d7ee8996beeced07fb4b3fc544f8c2_720w.jpg?source=3af55fa1" data-caption="" data-size="normal" data-rawwidth="777" data-rawheight="364" class="origin_image zh-lightbox-thumb" width="777" data-original="https://pic1.zhimg.com/v2-f4d7ee8996beeced07fb4b3fc544f8c2_720w.jpg?source=3af55fa1"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='777'%20height='364'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="777" data-rawheight="364" class="origin_image zh-lightbox-thumb lazy" width="777" data-original="https://pic1.zhimg.com/v2-f4d7ee8996beeced07fb4b3fc544f8c2_720w.jpg?source=3af55fa1" data-actualsrc="https://pic1.zhimg.com/v2-f4d7ee8996beeced07fb4b3fc544f8c2_720w.jpg?source=3af55fa1"></figure><p>For 則是</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-c1888d5243c41822948de4c725155381_720w.jpg?source=3af55fa1" data-caption="" data-size="normal" data-rawwidth="871" data-rawheight="451" class="origin_image zh-lightbox-thumb" width="871" data-original="https://pic1.zhimg.com/v2-c1888d5243c41822948de4c725155381_720w.jpg?source=3af55fa1"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='871'%20height='451'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="871" data-rawheight="451" class="origin_image zh-lightbox-thumb lazy" width="871" data-original="https://pic1.zhimg.com/v2-c1888d5243c41822948de4c725155381_720w.jpg?source=3af55fa1" data-actualsrc="https://pic1.zhimg.com/v2-c1888d5243c41822948de4c725155381_720w.jpg?source=3af55fa1"></figure><p><br></p><p>計上執行開銷後, for 和forEach 和運行效率上的差別還是微乎其微。只有在benchmark 時在能看上分別。</p><p><br></p><p>如果在服務器上執行, 在能夠使用forEach 的地方使用forEach 是明智之舉, 無必要用"緩存項數後的for", forEach 到for 完全可以在99%的情況都定義做過早優化。</p><p>map 的話, 因為效能遠不及forEach, 在發佈時會有可見的cpu 分別。</p><p>但如果真的對cpu 運行的控制度那麼敏感的話, javascript 完全不是一種合適的開發語言。</p><p><br></p><p>除了C, Rust 等控制欲強的語種外, GoLang, C#, Java 等等大部分強型態, 和編譯+運行過程直接的語言都是可以好好考慮的。</p><p>甚至LuaJit/PHP7 等等都不會給與你比起V8 更大的困擾。</p><p><br></p><p>要用node/V8的話, 盲目一點比較好。</p></div>
        <div id="permalink" style='word-break: break-all;padding:2em 0 2em 0'><a href="https://blog.abby.md/_generated_pages/answers/272040703.htm">Permalink of this blog</a></div>
        
    </div>
</body>
<script>
    $("img[data-actualsrc]").each(function(num,e){
        $(this).attr("src",$(this).attr("data-actualsrc"));
    });
    hljs.highlightAll();
</script>
</html>